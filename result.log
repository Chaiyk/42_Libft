ft_memset:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_bzero:      [OK] [OK] [OK] [OK] 
ft_memcpy:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memmove:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_memcmp:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlen:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_isalpha:    [OK] 
ft_isdigit:    [OK] 
ft_isalnum:    [OK] 
ft_isascii:    [OK] 
ft_isprint:    [OK] 
ft_toupper:    [OK] 
ft_tolower:    [OK] 
ft_strchr:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strrchr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strncmp:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcpy:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strlcat:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_strnstr:    [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_atoi:       [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_calloc:     [OK] [OK] [OK] [OK] [OK] 
ft_strdup:     [OK] [OK] [OK] [OK] [OK] [OK] [OK] 
ft_substr:     [OK] [OK] [OK] [FAILED] [OK] [OK] [OK] [OK] {protected}[FAILED] 
[fail]: your substr did not allocate the good size so the \0 test may be false
Test code:
	char *str = "i just want this part #############";
	size_t size = 10;
	int ret_size;

	ft_substr(str, 5, size);
	ret_size = get_last_malloc_size();
	if ((int)size + 1 == ret_size)
	{
		exit(TEST_SUCCESS);
	}
	exit(TEST_FAILED);

Diffs:
      substr: |11|
   ft_substr: |36|

[fail]: your substr does not work when start >= ft_strlen(s)
Test code:
	char *str = "01234";
	size_t size = 10;
	char *ret = ft_substr(str, 10, size);

	if (!strncmp(ret, "", 1))
	{
		free(ret);
		exit(TEST_SUCCESS);
	}
	free(ret);
	exit(TEST_FAILED);

Diffs:
      substr: ||
   ft_substr: | strjoin d|

ft_strjoin:    [CRASH] [CRASH] [OK] [OK] [OK] {not protected}
[crash]: your strjoin does not work with basic input
Test code:
	char *s1 = "my favorite animal is";
	char *s2 = " ";
	char *s3 = "the nyancat";
	char *res = ft_strjoin(ft_strjoin(s1, s2), s3);

	if (!strcmp(res, "my favorite animal is the nyancat"))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[crash]: your strjoin does not allocate the memory
Test code:
	char *s1 = "my favorite animal is";
	char *s2 = " ";
	char *s3 = "the nyancat";
	char *tmp = ft_strjoin(s1, s2);
	char *res = ft_strjoin(tmp, s3);

	free(tmp);
	if (!strcmp(res, "my favorite animal is the nyancat"))
	{
		free(res);
		exit(TEST_SUCCESS);
	}
	free(res);
	exit(TEST_FAILED);


ft_strtrim:    [OK] [OK] [OK] [FAILED] [FAILED] [KO] [OK] [OK] [OK] {not protected}
[fail]: your strtrim does not work with full blank input
Test code:
	char *s1 = "  \t \t \n   \n\n\n\t";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: ||
  ft_strtrim: |your strtrim did not allocate the good size so the \0 test may be false|

[fail]: your strtrim does not work with empty input
Test code:
	char *s1 = "";
	char *s2 = "";
	char *ret = ft_strtrim(s1, " \n\t");

	if (!strcmp(ret, s2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
     strtrim: ||
  ft_strtrim: |test basic du memcpy !|

[KO]: your strtrim did not allocate the good size so the \0 test may be false
Test code:
	char *s1 = "\t   \n\n\n  \n\n\t    Hello \t  Please\n Trim me !\t\t\t\n  \t\t\t\t  ";
	char *s2 = "Hello \t  Please\n Trim me !";
	int r_size = strlen(s2);
	int size;

	ft_strtrim(s1, " \n\t");
	size = get_last_malloc_size();
	if (size == r_size + 1)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
     strtrim: |27|
  ft_strtrim: |55|

ft_split:      [OK] [OK] [OK] [OK] [OK] [OK] [OK] [CRASH] [OK] [CRASH] {not protected}
[crash]: your split does not work with basic input
Test code:
	char *s = "split  ||this|for|me|||||!|";
	int i = 0;
	char **result = ft_split(s, '|');

	while (result[i])
	{
		if (strcmp(result[i], *expected))
		{
			exit(TEST_FAILED);
		}
		free(result[i]);
		i++;
		expected++;
	}
	free(result);
	exit(TEST_SUCCESS);


[crash]: your split does not work with basic input
Test code:
	char *s = "      split       this for   me  !       ";

	char **result = ft_split(s, ' ');
	while (*result)
	{
		if (strcmp(*result, *expected))
		{
			exit(TEST_FAILED);
		}
		result++;
		expected++;
	}
	exit(TEST_SUCCESS);


ft_itoa:       [OK] [OK] [OK] [FAILED] [OK] [OK] [KO] [OK] [OK] 
[fail]: your itoa does not work with min int
Test code:
	char *i1 = ft_itoa((-2147483647 -1));

	if (atoi(i1) != (-2147483647 -1))
	{
		exit(TEST_FAILED);
	}
	exit(TEST_SUCCESS);

Diffs:
        itoa: |-2147483648|
     ft_itoa: |-./,),(-*,(|

[KO]: your itoa does not allocate the good size so the \0 test may be false
Test code:
	int size;

	ft_itoa(-5859);
	size = get_last_malloc_size();
	if (size == 6)
		exit(TEST_SUCCESS);
	exit(TEST_KO);

Diffs:
        itoa: |6|
     ft_itoa: |7|

ft_strmapi:    [OK] [OK] [OK] [OK] [OK] {not protected}
ft_putchar_fd: [OK] [OK] 
ft_putstr_fd:  [OK] [OK] {not protected}
ft_putendl_fd: [OK] [OK] {protected}
ft_putnbr_fd:  [OK] [OK] [FAILED] [OK] [FAILED] 
[fail]: your putnbr_fd does not work with int min
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |2|

[fail]: your putnbr_fd allocate memory, wtf ???
Test code:
	int i = (-2147483647 -1);
	char buff[0xF0];

	fd_to_buffer(2);
	ft_putnbr_fd(i, 2);
	write(2, "", 1);
	get_fd_buffer(2, buff, 0xF0);
	if (atoi(buff) == i)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
   putnbr_fd: |-2147483648|
ft_putnbr_fd: |2|

ft_lstnew:     [MISSING]
ft_lstadd_front: [MISSING]
ft_lstsize:    [MISSING]
ft_lstlast:    [MISSING]
ft_lstadd_back:[MISSING]
ft_lstdelone:  [MISSING]
ft_lstclear:   [MISSING]
ft_lstiter:    [MISSING]
ft_lstmap:     [MISSING]
ft_striteri:   [FAILED] [OK] {protected}
[fail]: your striteri does no work
Test code:
	char b[] = "override this !";
	char b2[0xF0];
	size_t size = strlen(b);

	for (size_t i = 0; i < size; i++)
		f_striteri(i, b2 + i);
	b2[size] = 0;
	ft_striteri(b, f_striteri);
	if (!strcmp(b, b2))
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);

Diffs:
    striteri: |111111111111111|
 ft_striteri: |0123456789:;<=>|

ft_strndup:    [CRASH] [OK] [OK] [OK] [KO] [OK] [OK] [OK] 
[crash]: you dindn't protect your malloc return
Test code:
	char *ptr;

	ptr = ft_strndup("lol", 5);
	if (!ptr)
		exit(TEST_SUCCESS);
	exit(TEST_FAILED);


[KO]: your strndup did not allocate the good size so the \0 test may be false
Test code:
	char *tmp = "this is a normal test";
	int r_size = 5;
	int size;

	ft_strndup(tmp, r_size);
	size = get_last_malloc_size();
	if (size != r_size + 1)
	{
		exit(TEST_KO);
	}
	exit(TEST_SUCCESS);

Diffs:
     strndup: |6|
  ft_strndup: |48|

